/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.mrql;

import Gen.*;
import java.io.*;
import org.apache.hadoop.io.*;
import org.apache.hadoop.conf.Configuration;
import org.apache.hama.HamaConfiguration;


/** Evaluate a physical plan in BSP mode using Hama */
final public class Evaluator extends Interpreter {

    /** initialize the BSP evaluator */
    final static void init ( Configuration conf ) {
	Config.bsp_mode = true;
	if (Config.hadoop_mode && Config.local_hadoop_mode) {
	    conf.set("bsp.master.address","local");
	    conf.set("mapred.job.tracker","local");
	    conf.set("hama.zookeeper.quorum","localhost");
	    conf.set("bsp.local.tasks.maximum","2");     // BSP local mode uses a max of 2 cores
	    conf.set("fs.default.name","file:///");
	}
    }

    final static Configuration new_configuration () {
	return new HamaConfiguration();
    }

    public static MR_bool synchronize ( MR_bool mr_exit ) {
	return BSPPlan.BSPop.synchronize(mr_exit);
    }

    public static Bag distribute ( Bag s ) {
	return BSPPlan.BSPop.distribute(s);
    }

    /** Evaluate MRQL physical operators using BSP
     * @param e the physical plan
     * @param env contains bindings fro variables to values (MRData)
     * @return a DataSet (stored in HDFS)
     */
    final static MRData bsp ( Tree plan, Environment env ) throws Exception {
	match plan {
	case BSP(tuple(...ns),`superstep,`init_state,`o,...S):
	    int[] os = new int[ns.length()];
	    for ( int i = 0; i < os.length; i++ )
		os[i] = (int)((LongLeaf)ns.nth(i)).value();
	    DataSet ds = eval(S.head(),env);
	    for ( Tree s: S.tail() )
		ds.merge(eval(s,env));
	    return BSPPlan.BSP(os,
			       closure(superstep,env),
			       init_state,
			       o.equals(#<true>),
			       ds);
	case BSP(`n,`superstep,`init_state,`o,...S):
	    DataSet ds = eval(S.head(),env);
	    for ( Tree s: S.tail() )
		ds.merge(eval(s,env));
	    return BSPPlan.BSP(new int[]{(int)((LongLeaf)n).value()},
			       closure(superstep,env),
			       init_state,
			       o.equals(#<true>),
			       ds);
	}
	throw new Error("Cannot perform the BSP plan: "+plan);
    }

    /** The Aggregate physical operator
     * @param acc_fnc  the accumulator function from (T,T) to T
     * @param zero  the zero element of type T
     * @param plan the plan that constructs the dataset that contains the bag of values {T}
     * @param env contains bindings fro variables to values (MRData)
     * @returns the aggregation result of type T
     */
    final static MRData aggregate ( Tree acc_fnc,
				    Tree zero,
				    Tree plan,
				    Environment env ) throws Exception {
	match plan {
	case BSP(`n,`superstep,`init_state,`o,...S):
	    DataSet ds = eval(S.head(),env,"-");
	    for ( Tree s: S.tail() )
		ds.merge(eval(s,env,"-"));
	    return BSPPlan.BSPaggregate((int)((LongLeaf)n).value(),
					closure(superstep,env),
					init_state,
					closure(acc_fnc,env),
					zero,
					ds);
	}
	throw new Error("Cannot perform the aggregation: "+plan);
    }

    final static Tuple loop ( Tree e, Environment env ) {
	throw new Error("The BSP Loop was supposed to be translated to a BSP task");
    }

    final static DataSet eval ( final Tree e,
				final Environment env,
				final String counter ) {
	return eval(e,env);
    }

    /** Evaluate MRQL BSP physical operators using Hama (returns a DataSet)
     *   and print tracing info
     * @param e the physical plan
     * @param env contains bindings fro variables to values (MRData)
     * @return a DataSet (stored in HDFS)
     */
    final static DataSet eval ( final Tree e, final Environment env ) {
	if (Config.trace_execution) {
	    tab_count += 3;
	    System.out.println(tabs(tab_count)+print_query(e));
	};
	DataSet res = evalD(e,env);
	if (Config.trace_execution) 
	    try {
		System.out.println(tabs(tab_count)
				   +"-> "+Plan.collect(res,false));
		tab_count -= 3;
	    } catch (Exception ex) {
		throw new Error("Cannot collect the operator output: "+e);
	    };
	return res;
    }

    /** Evaluate MRQL BSP physical operators using Hama (returns a DataSet)
     * @param e the physical plan
     * @param env contains bindings fro variables to values (MRData)
     * @return a DataSet (stored in HDFS)
     */
    final static DataSet evalD ( final Tree e, final Environment env ) {
	try {
	    match e {
	    case BSPSource(`n,BinarySource(`file,_)):
		return Plan.binarySource((int)((LongLeaf)n).value(),file.stringValue());
	    case BSPSource(`n,ParsedSource(`parser,`file,...args)):
		Class<? extends Parser> p = DataSource.parserDirectory.get(parser.toString());
		if (p == null)
		    throw new Error("Unknown parser: "+parser);
		return Plan.parsedSource((int)((LongLeaf)n).value(),
					 p,((MR_string)evalE(file,env)).get(),args);
	    case BSPSource(`n,Generator(`min,`max,`size)):
		return Plan.generator((int)((LongLeaf)n).value(),
				      ((MR_long)evalE(min,env)).get(),
				      ((MR_long)evalE(max,env)).get(),
				      ((MR_long)evalE(size,env)).get());
	    case Merge(`x,`y):
		return Plan.merge(eval(x,env),eval(y,env));
	    case Dump(`s):
		return Plan.fileCache((Bag)evalE(s,env));
	    case apply(`f,`arg):
		if (!f.is_variable())
		    return ((MR_dataset)evalF(f,env).eval(evalE(arg))).dataset();
		MRData fnc = variable_lookup(f.toString(),global_env);
		if (fnc == null)
		    throw new Error("Unknown function: "+f);
		MRData t = evalE(arg,env);
		if (!(t instanceof Tuple))
		    throw new Error("Expected a tuple in function application: "+t);
		return ((MR_dataset)((Lambda)fnc).lambda().eval(t)).dataset();
	    case `v:
		if (!v.is_variable())
		    fail;
		MRData x = variable_lookup(v.toString(),env);
		if (x != null)
		    if (x instanceof MR_dataset)
			return ((MR_dataset)x).dataset();
		x = variable_lookup(v.toString(),global_env);
		if (x != null)
		    if (x instanceof MR_dataset)
			return ((MR_dataset)x).dataset();
		throw new Error("Variable "+v+" is not bound");
	    };
	    MRData d = bsp(e,env);
	    if (d instanceof MR_dataset)
		return ((MR_dataset)d).dataset();
	    throw new Error("Cannot evaluate the BSP plan: "+e);
	} catch (Error msg) {
	    if (!Config.trace)
		throw new Error(msg.getMessage());
	    System.err.println(msg.getMessage());
	    throw new Error("Evaluation error in: "+print_query(e));
	} catch (Exception ex) {
	    System.err.println(ex.getMessage());
	    ex.printStackTrace();
	    throw new Error("Evaluation error in: "+print_query(e));
	}
    }
}
