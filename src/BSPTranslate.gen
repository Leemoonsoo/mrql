/********************************************************************************
   Copyright 2011-2012 Leonidas Fegaras, University of Texas at Arlington

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   File: BSPTranslate.gen
   Translate MR plans to BSP physical plans
   Programmer: Leonidas Fegaras, UTA
   Date: 06/01/12 - 08/15/12

********************************************************************************/

package hadoop.mrql;

import Gen.*;


class BSPTranslate extends Translate {
    final static int orM = ClassImporter.find_method_number("or",#[bool,bool]);
    final static int andM = ClassImporter.find_method_number("and",#[bool,bool]);
    final static int notM = ClassImporter.find_method_number("not",#[bool]);
    final static int eqM = ClassImporter.find_method_number("eq",#[int,int]);
    final static int plusM = ClassImporter.find_method_number("plus",#[int,int]);
    final static int neqM = ClassImporter.find_method_number("neq",#[int,int]);
    final static int geqM = ClassImporter.find_method_number("geq",#[long,long]);
    final static int gtM = ClassImporter.find_method_number("gt",#[int,int]);
    final static int unionM = ClassImporter.find_method_number("union",#[bag(any),bag(any)]);
    final static int countM = ClassImporter.find_method_number("count",#[bag(any)]);
    final static int coerceM = ClassImporter.find_method_number("coerce",#[any,int]);
    final static Trees data_source_operations = #[BinarySource,ParsedSource,Generator];

    private static int source_num = 0;

    public static void reset () {
	source_num = 0;
    }

    // add a new source num to every BSP operation
    public static Tree preprocess ( Tree e ) {
	match e {
	case lambda(`v,`b):
	    return #<lambda(`v,`(preprocess(b)))>;
	case `f(...as):
	    if (!data_source_operations.member(#<`f>))
		fail;
	    return #<`f(`(source_num++),...as)>;
	case `f(...as):
	    Trees bs = #[];
	    for (Tree a: as)
		bs = bs.append(preprocess(a));
	    return #<`f(...bs)>;
	};
	return e;
    }

   // return the source num of a BSP operation
    private static int source_num ( Tree e ) {
	match e {
	case BSP(`i,...):
	    return (int)((LongLeaf)i).value();
	case `f(`i,...):
	    if (!data_source_operations.member(#<`f>))
		fail;
	    return (int)((LongLeaf)i).value();
	};
	return -1;
    }

   // return the source numbers of a BSP operation
    private static Trees source_nums ( Tree e ) {
	match e {
	case BSP(`i,...):
	    return #[`i];
	case Merge(`x,`y):
	    return source_nums(x).append(source_nums(y));
	case `f(`i,...):
	    if (!data_source_operations.member(#<`f>))
		fail;
	    return #[`i];
	};
	return #[];
    }

    // optimizations after BSP fusion
    private static Tree post_simplify ( Tree e ) {
	match e {
	case cmap(lambda(`x,`S(`a)),`b):
	    if (is_collection(S))
		return post_simplify(#<map(lambda(`x,`a),`b)>);
	    else fail
	case `f(...as):
	    Trees bs = #[];
	    for (Tree a: as)
		bs = bs.append(post_simplify(a));
	    return #<`f(...bs)>;
	};
	return e;
    }

    private static Tree processBSP ( Tree e ) {
	return post_simplify(simplify_all(rename(e)));
    }

    private static Tree mkBSP ( Tree superstep, Tree state, Tree orderp, Tree input ) {
	int sn = source_num(input);
	superstep = processBSP(subst(#<i_>,#<`sn>,superstep));
	return #<BSP(`sn,`superstep,`state,`orderp,`input)>;
    }

    private static Tree mkBSPL ( Tree superstep, Tree state, Tree orderp, Trees input ) {
	int sn = source_num(input.nth(0));
	superstep = processBSP(subst(#<i_>,#<`sn>,superstep));
	return #<BSP(`sn,`superstep,`state,`orderp,...input)>;
    }

    private static Tree mkBSP2 ( Tree superstep, Tree state, Tree orderp, Tree left, Tree right ) {
	int sn = source_num(left);
	superstep = processBSP(subst(#<i_>,#<`sn>,superstep));
	return #<BSP(`sn,`superstep,`state,`orderp,`left,`right)>;
    }

    public static Tree mr2bsp ( Tree e ) {
	match e {
	case Aggregate(`acc,`zero,`S):
	    return #<Aggregate(`acc,`zero,`(mr2bsp(S)))>;
	case cMap(`f,`S):
	    return mkBSP(#<lambda(tuple(ms,as,k),
				  tuple(BAG(),
					cmap(lambda(tuple(kk,c),
						    cmap(lambda(x,bag(tuple(i_,x))),
							 apply(`f,c))),
					     as),
					tuple(),
					TRUE()))>,
			 #<tuple()>,
			 #<false>,
			 mr2bsp(S));
	case AggregateMap(`f,`acc,`zero,`S):
	    return mkBSP(#<lambda(tuple(ms,as,k),
				  tuple(BAG(),
					aggregate(`acc,`zero,
						  cmap(lambda(tuple(kk,c),
							      apply(`f,c)),
						       as)),
					tuple(),
					TRUE()))>,
			 #<tuple()>,
			 #<false>,
			 mr2bsp(S));
	case MapReduce(`m,`r,`S,`o):
	    return mkBSP(#<lambda(tuple(ms,as,b),
				  if(b,
				     tuple(cmap(lambda(tuple(k,c),
						       bag(tuple(k,tuple(k,c)))),
						cmap(lambda(tuple(k,c),apply(`m,c)),
						     as)),
					   bag(),
					   false,
					   FALSE()),
				     tuple(BAG(),
					   cmap(lambda(tuple(k,s),
						       cmap(lambda(x,bag(`(o.equals(#<true>)
									   ? #<tuple(i_,x,k)>
									   : #<tuple(i_,x)>))),
							    apply(`r,tuple(k,s)))),
						groupBy(ms)),
					   false,
					   TRUE())))>,
			 #<true>,
			 o,
			 mr2bsp(S));
        case MapAggregateReduce(`m,`r,`acc,`zero,`S,_):
            return mkBSP(#<lambda(tuple(ms,as,b),
                                  if(b,
                                     tuple(cmap(lambda(tuple(k,c),
                                                       bag(tuple(k,tuple(k,c)))),
                                                cmap(lambda(tuple(k,c),apply(`m,c)),
                                                     as)),
                                           bag(),
                                           false,
                                           FALSE()),
                                     tuple(BAG(),
                                           aggregate(`acc,`zero,
                                                     cmap(`r,groupBy(ms))),
                                           false,
                                           TRUE())))>,
                         #<true>,
                         #<false>,
                         mr2bsp(S));
	case MapCombineReduce(`m,`c,`r,`S,`o):
	    return mkBSP(#<lambda(tuple(ms,as,b),
				  if(b,
				     tuple(cmap(lambda(tuple(k,s),
						       cmap(lambda(x,bag(tuple(k,tuple(k,x)))),
							    apply(`c,tuple(k,s)))),
						groupBy(cmap(lambda(tuple(k,c),apply(`m,c)),
							    as))),
					   bag(),
					   false,
					   FALSE()),
				     tuple(BAG(),
					   cmap(lambda(tuple(k,s),
						       cmap(lambda(x,bag(`(o.equals(#<true>)
									   ? #<tuple(i_,x,k)>
									   : #<tuple(i_,x)>))),
							    apply(`r,tuple(k,s)))),
						groupBy(ms)),
					   false,
					   TRUE())))>,
			 #<true>,
			 o,
			 mr2bsp(S));
	case MapReduce2(`mx,`my,`r,`x,`y,`o):
	    return mkBSP2(#<lambda(tuple(ms,as,b),
				   if(b,
				      tuple(cmap(lambda(tuple(k,c),
							if(callM(eq,`eqM,k,i_),
							   cmap(lambda(tuple(kk,cc),
								       bag(tuple(kk,tuple(kk,tuple(1,cc))))),
								apply(`mx,c)),
							   cmap(lambda(tuple(kk,cc),
								       bag(tuple(kk,tuple(kk,tuple(2,cc))))),
								apply(`my,c)))),
						 as),
					    bag(),
					    false,
					    FALSE()),
				      tuple(BAG(),
					    cmap(lambda(tuple(k,s),
							cmap(lambda(x,bag(`(o.equals(#<true>)
									    ? #<tuple(i_,x,k)>
									    : #<tuple(i_,x)>))),
							     apply(`r,
								   tuple(cmap(lambda(tuple(nx,x),
										     if(callM(eq,`eqM,nx,1),
											bag(x),
											bag())),
									      s),
									 cmap(lambda(tuple(ny,y),
										     if(callM(eq,`eqM,ny,2),
											bag(y),
											bag())),
									      s))))),
						 groupBy(ms)),
					    false,
					    TRUE())))>,
			  #<true>,
			  o,
			  mr2bsp(x),
			  mr2bsp(y));
	case MapAggregateReduce2(`mx,`my,`r,`acc,`zero,`x,`y,_):
	    return mkBSP2(#<lambda(tuple(ms,as,b),
				   if(b,
				      tuple(cmap(lambda(tuple(k,c),
							if(callM(eq,`eqM,k,i_),
							   cmap(lambda(tuple(kk,cc),
								       bag(tuple(kk,tuple(kk,tuple(1,cc))))),
								apply(`mx,c)),
							   cmap(lambda(tuple(kk,cc),
								       bag(tuple(kk,tuple(kk,tuple(2,cc))))),
								apply(`my,c)))),
						 as),
					    bag(),
					    false,
					    FALSE()),
				      tuple(BAG(),
					    aggregate(`acc,`zero,
						      cmap(lambda(tuple(k,s),
								  apply(`r,
									tuple(cmap(lambda(tuple(nx,x),
											  if(callM(eq,`eqM,nx,1),
											     bag(x),
											     bag())),
										   s),
									      cmap(lambda(tuple(ny,y),
											  if(callM(eq,`eqM,ny,2),
											     bag(y),
											     bag())),
										   s)))),
							   groupBy(ms))),
					    false,
					    TRUE())))>,
			  #<true>,
			  #<false>,
			  mr2bsp(x),
			  mr2bsp(y));
	case MapJoin(`mx,`my,`r,`x,`y):
	    return mr2bsp(#<MapReduce2(`mx,`my,
				       lambda(tuple(xs,ys),cmap(lambda(x,apply(`r,tuple(x,ys))),xs)),
				       `x,`y,false)>);
	case MapAggregateJoin(`mx,`my,`r,`acc,`zero,`x,`y):
	    return mr2bsp(#<MapAggregateReduce2(`mx,`my,
						lambda(tuple(xs,ys),cmap(lambda(x,apply(`r,tuple(x,ys))),xs)),
						`acc,`zero,`x,`y)>);
	case Repeat(lambda(`v,`b),`ds,`max):
	    match bspSimplify(mr2bsp(b)) {
	    case BSP(`n,`s,`k0,_,`S):	   // no extra data sources
		if (!S.equals(v))
		    fail;
		return mkBSP(#<lambda(tuple(ms,vs,tuple(k,steps)),
				      let(tuple(ts,bs,kk,b),
					  apply(`s,tuple(ms,vs,k)),
					  if(b,   // end of repeat step
					     tuple(bag(),
						   map(lambda(tuple(z,tuple(x,bb)),tuple(z,x)),bs),
						   tuple(`k0,callM(add,`plusM,steps,1)),
						   if(callM(gt,`gtM,steps,`max),
						      TRUE(),           // if # of steps <= limit, exit
						      callM(not,`notM,  // ... else check the stopping condition
							    aggregate(lambda(tuple(x,y),callM(or,`orM,x,y)),
								      false,
								      map(lambda(tuple(z,tuple(x,bb)),bb),bs))))),
					     tuple(ts,bs,tuple(kk,steps),FALSE()))))>,
			     #<tuple(`k0,1)>,
			     #<false>,
			     mr2bsp(ds));
	    case BSP(`n,`s,`k0,_,...as):      // repeat loop uses extra data sources
		// the initial value of the repeat variable (an input data source)
		Tree ds_source = mr2bsp(ds);
		// the initial values of all data sources
		Trees sources = #[`ds_source];
		for ( Tree x: as )
		    if (!x.equals(v))
			sources = sources.append(x);
		Trees sn = source_nums(ds_source);
		// filter used in extracting the extra sources (the immutable data sources)
		Tree ncond = #<callM(neq,`neqM,n,`(sn.head()))>;
		for ( Tree i: sn.tail() )
		    ncond = #<callM(and,`andM,`ncond,callM(neq,`neqM,n,`i))>;
		return mkBSPL(#<lambda(tuple(ms,vs,tuple(k,steps,firstp,sources)),
				       let(tuple(ts,bs,kk,b),
					   apply(`s,tuple(ms,vs,k)),
					   if(b,   // end of repeat step
					      let(S,sources,   // materialize the extra sources in memory
						  tuple(bag(),
							callM(union,`unionM,
							      map(lambda(tuple(z,tuple(x,bb)),tuple(z,x)),bs),
							      S),
							tuple(`k0,callM(add,`plusM,steps,1),
							      false,
							      if(firstp,
								 // filter out the repeat var data
								 cmap(lambda(tuple(n,x),
									     if(`ncond,bag(tuple(n,x)),bag())),
								      vs),
								 S)),
							if(callM(gt,`gtM,steps,`max),
							   TRUE(),           // if # of steps <= limit, exit
							   callM(not,`notM,  // ... else check the stopping condition
								 aggregate(lambda(tuple(x,y),callM(or,`orM,x,y)),
									   false,
									   map(lambda(tuple(z,tuple(x,bb)),bb),bs)))))),
					      tuple(ts,
						    bs,
						    tuple(kk,steps,false,
							  if(firstp,
							     // filter out the repeat var data
							     cmap(lambda(tuple(n,x),
									 if(`ncond,bag(tuple(n,x)),bag())),
								  vs),
							     sources)),
						    FALSE()))))>,
			      #<tuple(`k0,1,true,bag())>,
			      #<false>,
			      sources);
	    case `x: throw new Error("Cannot compile the repeat function: "+x);
	    }
	// when the repeat variable is in memory
	case repeat(lambda(`v,`b),`ds,`max):
	    match bspSimplify(mr2bsp(b)) {
	    case BSP(`n,`s,`k0,_,...as):
		// contains all input sources except the repeat variable
		Trees sources = #[];
		for ( Tree a: as )
		    if (!a.equals(v))
			sources = sources.append(a);
		Tree res = mkBSPL(#<lambda(tuple(ms,vs,tuple(k,steps,S,firstp,sources)),
				      let(`v,S,       // materialize the repeat variable in memory
					  let(tuple(ts,bs,kk,b),
					      apply(`s,tuple(ms,materialize(vs),k)),
					      if(b,   // at the end of repeat step
						 let(exit,if(callM(gt,`gtM,steps,`max),
							     TRUE(),           // if # of steps <= limit, exit
							     callM(not,`notM,  // ... else check the stopping condition
								   aggregate(lambda(tuple(x,y),callM(or,`orM,x,y)),
									     false,
									     map(lambda(tuple(z,tuple(x,bb)),bb),bs)))),
						     tuple(bag(),
							   if(exit,
							      map(lambda(tuple(z,tuple(x,bb)),tuple(z,x)),bs),
							      sources),
							   tuple(`k0,
								 callM(add,`plusM,steps,1),
								 // need to collect the repeat var value from all peers
								 distribute(map(lambda(tuple(z,tuple(x,bb)),x),bs)),
								 false,
								 if(firstp,vs,sources)),
							   exit)),
						 tuple(ts,   // within the repeat step
						       bs,
						       tuple(kk,steps,`v,false,
							     if(firstp,vs,sources)),
						       FALSE())))))>,
				 #<tuple(`k0,1,`(mr2bsp(ds)),true,bag())>,
				 #<false>,
				 sources);
		return #<Collect(`res)>;   // must return a memory bag
	    case `x: throw new Error("Cannot compile the repeat function: "+x);
	    }
	case Closure(lambda(`v,`b),`ds,`max):
	    match bspSimplify(mr2bsp(b)) {
	    case BSP(`n,`s,`k0,_,...as):
		// the initial value of the repeat variable (an input data source)
		Tree ds_source = mr2bsp(ds);
		// the initial values of all data sources
		Trees sources = #[`ds_source];
		for ( Tree x: as )
		    if (!x.equals(v))
			sources = sources.append(x);
		Trees sn = source_nums(ds_source);
		// filter used in extracting the extra sources (the immutable data sources)
		Tree ncond = #<callM(neq,`neqM,n,`(sn.head()))>;
		for ( Tree i: sn.tail() )
		    ncond = #<callM(and,`andM,`ncond,callM(neq,`neqM,n,`i))>;
		return mkBSPL(#<lambda(tuple(ms,vs,tuple(k,steps,firstp,len,sources)),
				       let(tuple(ts,bs,kk,b),
					   apply(`s,tuple(ms,vs,k)),
					   if(b,   // end of repeat step
					      let(S,sources,   // materialize the extra sources in memory
						  let(mbs,bs,  // materialize bs in memory
						      let(newLen,callM(count,`countM,mbs),
							  tuple(bag(),
								callM(union,`unionM,mbs,S),
								tuple(`k0,callM(add,`plusM,steps,1),
								      false,newLen,
								      if(firstp,
									 // filter out the repeat var data
									 cmap(lambda(tuple(n,x),
										     if(`ncond,bag(tuple(n,x)),bag())),
									      vs),
									 S)),
								if(callM(gt,`gtM,steps,`max),
								   TRUE(),           // if # of steps <= limit, exit
								   // ... else check if the new size is the same as the old size
								   callM(geq,`geqM,len,newLen)))))),
					      tuple(ts,
						    bs,
						    tuple(kk,steps,false,len,
							  if(firstp,
							     // filter out the repeat var data
							     cmap(lambda(tuple(n,x),
									 if(`ncond,bag(tuple(n,x)),bag())),
								  vs),
							     sources)),
						    FALSE()))))>,
			      #<tuple(`k0,1,true,callM(coerce,`coerceM,0,4),bag())>,
			      #<false>,
			      sources);
	    case `x: throw new Error("Cannot compile the closure function: "+x);
	    }
	case CrossProduct(`mx,`my,`r,`x,`y):
	    return mkBSP(#<lambda(tuple(ms,xs,ys),
				  tuple(BAG(),
					cmap(lambda(tuple(kx,x),
						    cmap(lambda(xx,
								cmap(lambda(y,
									    cmap(lambda(yy,
											cmap(lambda(z,bag(tuple(i_,z))),
											     apply(`r,tuple(xx,yy)))),
										 apply(`my,y))),
								     ys)),
							 apply(`mx,x))),
					     xs),
					tuple(),
					TRUE()))>,
			 #<Collect(`(mr2bsp(y)))>,
			 #<false>,
			 mr2bsp(x));
	case CrossAggregateProduct(`mx,`my,`r,`acc,`zero,`x,`y):
	    return mkBSP(#<lambda(tuple(ms,xs,ys),
				  tuple(BAG(),
					aggregate(`acc,`zero,
					cmap(lambda(tuple(kx,x),
						    cmap(lambda(xx,
								cmap(lambda(y,
									    cmap(lambda(yy,
											cmap(lambda(z,bag(tuple(i_,z))),
											     apply(`r,tuple(xx,yy)))),
										 apply(`my,y))),
								     ys)),
							 apply(`mx,x)))),
					     xs),
					tuple(),
					TRUE()))>,
			 #<Collect(`(mr2bsp(y)))>,
			 #<false>,
			 mr2bsp(x));
	case `f(...as):
	    Trees bs = #[];
	    for ( Tree a: as )
		bs = bs.append(mr2bsp(a));
	    return #<`f(...bs)>;
	};
	return e;
    }

    public static Tree bspSimplify ( Tree e ) {
	match e {
	case BSP(_,`s2,`k2,`o,...r,BSP(_,`s1,`k1,_,...s),...t):
	    return bspSimplify(mkBSPL(#<lambda(tuple(ms,as,tuple(b,k)),
					       if(b,
						  let(tuple(ts,bs,kk,bb),apply(`s1,tuple(ms,as,k)),
                                                      let(exit,
							  synchronize(bb),   // poll all peers: do you want to exit?
							  // all peers must aggree to exit the inner BSP
							  //    and proceed to the outer BSP
							  tuple(ts,bs,tuple(callM(not,`notM,exit),
									    if(exit,`k2,kk)),FALSE()))),
						  let(tuple(ts,bs,kk,bb),apply(`s2,tuple(ms,as,k)),
						      tuple(ts,bs,tuple(false,kk),bb))))>,
				      #<tuple(true,`k1)>,
				      o,
				      #[...r,...s,...t]));
	case lambda(...):
	    fail
	case `f(...as):
	    Trees bs = #[];
	    for ( Tree a: as )
		bs = bs.append(bspSimplify(a));
	    return #<`f(...bs)>;
	};
	return e;
    }
}
